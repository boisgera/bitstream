{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Bitstream is a Python library to manage binary data as bitstreams: >>> from bitstream import BitStream >>> BitStream(b\"Hello World!\") 010010000110010101101100011011000110111100100000010101110110111101110010011011000110010000100001 If you need to deal with existing binary file formats, or design your own binary formats or experiment with data compression algorithms, etc. and if the Python standard library doesn't work for you, you may be interested in bitstream. Read this section and have a look at the example applications to see if it is what you need. The main features are: Easy to use Bitstreams are a simple abstraction. They behave like communication channels: you can only write data at one end of it and read data at the other end, in the same order. So you only need to know how to create a stream, write into it and read it to use this library: >>> stream = BitStream() >>> stream.write(b\"Hello\") >>> stream.write(b\" World!\") >>> stream.read(bytes, 5) # doctest: +BYTES b'Hello' >>> stream.read(bytes, 7) # doctest: +BYTES b' World!' This simple way to manage binary data is good enough for a surprisingly large number of use cases. It should be much easier to use than struct and array , the modules that the standard Python library provides for this task. Works at the bit and byte level. Compact codes (for example Huffman codes ) do not always represent data with an entire number of bytes. Since bitstream supports bits and not merely bytes, such codes are implemented with the same API. For example, the unary coding of a sequence natural numbers requires only a few lines: >>> data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> stream = BitStream() >>> for number in data: ... stream.write(number * [True] + [False]) ... >>> stream 0101101110111101111101111110111111101111111101111111110 Supports Python & NumPy types BitStream has built-in support for the common data types with a standard binary layout: bools, bytes, fixed-size integers and floating-point integers. >>> stream = BitStream() >>> stream.write(True, bool) >>> stream.write(False, bool) >>> from numpy import int8 >>> stream.write(-128, int8) >>> stream.write(b\"AB\", bytes) >>> stream 10100000000100000101000010 >>> stream.read(bool, 2) [True, False] >>> stream.read(int8, 1) array([-128], dtype=int8) >>> stream.read(bytes, 2) # doctest: +BYTES b'AB' NumPy arrays are a convenient way to deal with sequences of homogeneous data: >>> from numpy import * >>> dt = 1.0 / 44100.0 >>> t = r_[0.0:1.0:dt] >>> data = cos(2*pi*440.0*t) >>> stream = BitStream(data) Refer to the Built-in types section for more details. Advanced features Performance. Bitstream is a Python C-extension module that has been optimized for the common use cases. Hopefully, it will be fast enough for your needs! Under the hood, the Cython language and compiler are used to generate this extension module. Custom types. The list of supported types and binary representation may be enlarged at will: new readers and writers can be implemented and associated to specific data types. See also: Custom types . Snapshots. At times, the stream abstraction is too simple, for example when you need to lookahead into the stream without consuming its content. Snapshots are an extension of the stream model that solve this kind of issue since they provide a \"time machine\" to restore a stream to an earlier state. See also: Snapshots . Open Source Bitstream is distributed under a MIT license . The development takes place on GitHub and releases are distributed on PyPI .","title":"Overview"},{"location":"#overview","text":"Bitstream is a Python library to manage binary data as bitstreams: >>> from bitstream import BitStream >>> BitStream(b\"Hello World!\") 010010000110010101101100011011000110111100100000010101110110111101110010011011000110010000100001 If you need to deal with existing binary file formats, or design your own binary formats or experiment with data compression algorithms, etc. and if the Python standard library doesn't work for you, you may be interested in bitstream. Read this section and have a look at the example applications to see if it is what you need. The main features are: Easy to use Bitstreams are a simple abstraction. They behave like communication channels: you can only write data at one end of it and read data at the other end, in the same order. So you only need to know how to create a stream, write into it and read it to use this library: >>> stream = BitStream() >>> stream.write(b\"Hello\") >>> stream.write(b\" World!\") >>> stream.read(bytes, 5) # doctest: +BYTES b'Hello' >>> stream.read(bytes, 7) # doctest: +BYTES b' World!' This simple way to manage binary data is good enough for a surprisingly large number of use cases. It should be much easier to use than struct and array , the modules that the standard Python library provides for this task. Works at the bit and byte level. Compact codes (for example Huffman codes ) do not always represent data with an entire number of bytes. Since bitstream supports bits and not merely bytes, such codes are implemented with the same API. For example, the unary coding of a sequence natural numbers requires only a few lines: >>> data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> stream = BitStream() >>> for number in data: ... stream.write(number * [True] + [False]) ... >>> stream 0101101110111101111101111110111111101111111101111111110 Supports Python & NumPy types BitStream has built-in support for the common data types with a standard binary layout: bools, bytes, fixed-size integers and floating-point integers. >>> stream = BitStream() >>> stream.write(True, bool) >>> stream.write(False, bool) >>> from numpy import int8 >>> stream.write(-128, int8) >>> stream.write(b\"AB\", bytes) >>> stream 10100000000100000101000010 >>> stream.read(bool, 2) [True, False] >>> stream.read(int8, 1) array([-128], dtype=int8) >>> stream.read(bytes, 2) # doctest: +BYTES b'AB' NumPy arrays are a convenient way to deal with sequences of homogeneous data: >>> from numpy import * >>> dt = 1.0 / 44100.0 >>> t = r_[0.0:1.0:dt] >>> data = cos(2*pi*440.0*t) >>> stream = BitStream(data) Refer to the Built-in types section for more details. Advanced features Performance. Bitstream is a Python C-extension module that has been optimized for the common use cases. Hopefully, it will be fast enough for your needs! Under the hood, the Cython language and compiler are used to generate this extension module. Custom types. The list of supported types and binary representation may be enlarged at will: new readers and writers can be implemented and associated to specific data types. See also: Custom types . Snapshots. At times, the stream abstraction is too simple, for example when you need to lookahead into the stream without consuming its content. Snapshots are an extension of the stream model that solve this kind of issue since they provide a \"time machine\" to restore a stream to an earlier state. See also: Snapshots . Open Source Bitstream is distributed under a MIT license . The development takes place on GitHub and releases are distributed on PyPI .","title":"Overview"},{"location":"API/","text":"API Reference \u00b6 We assume in the sequel that all symbols of NumPy and BitStream are available: >>> from numpy import * >>> from bitstream import * Constructor \u00b6 Most of the library features are available through the BitStream class: BitStream() Create an empty bitstream. Usage >>> stream = BitStream() BitStream(data, type=None) Create an empty bitstream, then call the write method. Arguments data is the data to be encoded. The data type should be consistent with the type argument. type is a type identifier (such as bool , bytes , int8 , etc.). type can be omitted if data is an instance of a registered type or a list or 1d NumPy array of such instances. Usage >>> stream = BitStream([False, True]) >>> stream = BitStream(b\"Hello\", bytes) >>> stream = BitStream(42, uint8) See also Read / Write Read / Write \u00b6 BitStream.write(self, data, type=None) Encode data and append it to the stream. Arguments data is the data to be encoded. Its type should be consistent with the type argument. type is a type identifier (such as bool , str , int8 , etc.). type can be omitted if data is an instance of a registered type or a list or 1d NumPy array of such instances. Usage >>> stream = BitStream() >>> stream.write(True, bool) # explicit bool type >>> stream.write(False) # implicit bool type >>> stream.write(3*[False], bool) # list (explicit type) >>> stream.write(3*[True]) # list (implicit type) >>> stream.write(b\"AB\", bytes) # bytes >>> stream.write(-128, int8) # signed 8 bit integer See also Builtin Types Custom Types BitStream.read(self, type=None, n=None) Decode and consume n items of data from the start of the stream. Arguments type : type identifier (such as bool , bytes , int8 , etc.) If type is None a bitstream is returned. n : number of items to read For most types, n=None reads one item, but some types use a different convention. Returns data : n items of data The type of data depends on type and n . For built-in types: type n = None n = 0, 1, 2, ... bool bool list of bools BitStream BitStream BitStream bytes bytes bytes numpy.uint8 numpy.uint8 numpy.array numpy.int8 numpy.int8 numpy.array numpy.uint16 numpy.int16 numpy.array ... ... ... float float numpy.array Usage >>> stream = BitStream(b\"Hello World!\") >>> stream.read(bytes, 2) # doctest: +BYTES b'He' >>> stream.read(bool) False >>> stream.read(bool, 7) [True, True, False, True, True, False, False] >>> stream.read(uint8, 2) array([108, 111], dtype=uint8) >>> stream.read(uint8) 32 >>> stream.read(bytes) # doctest: +BYTES b'World!' See also Builtin Types Custom Types String Representation \u00b6 BitStream.__str__(self) Represent the stream as a string of '0' and '1' . Usage >>> print(BitStream(b\"ABC\")) 010000010100001001000011 BitStream.__repr__(self) Represent the stream as a string of '0' and '1' . Usage >>> BitStream(b\"ABC\") 010000010100001001000011 Copy \u00b6 Bitstreams can be copied non-destructively with BitStream.copy . They also support the interface required by the standard library copy module. BitStream.copy(self, n=None) Copy (partially or totally) the stream. Copies do not consume the stream they read. Arguments n : unsigned integer of None . The number of bits to copy from the start of the stream. The full stream is copied if n is None. Returns stream : a bitstream. Raises ReadError if n is larger than the length of the stream. Usage >>> stream = BitStream(b\"A\") >>> stream 01000001 >>> copy = stream.copy() >>> copy 01000001 >>> stream 01000001 >>> stream.copy(4) 0100 >>> stream 01000001 >>> stream.read(BitStream, 4) 0100 >>> stream 0001 BitStream.__copy__(self) Bitstream shallow copy. Usage >>> from copy import copy >>> stream = BitStream(b\"A\") >>> stream 01000001 >>> copy(stream) 01000001 >>> stream 01000001 BitStream.__deepcopy__(self, memo) Bitstream deep copy. Usage >>> from copy import deepcopy >>> stream = BitStream(b\"A\") >>> stream 01000001 >>> deepcopy(stream) 01000001 >>> stream 01000001 Length and Comparison \u00b6 BitStream.__len__(self, other) Return the bitstream length in bits. Usage >>> stream = BitStream([True, False]) >>> len(stream) 2 >>> stream = BitStream(b\"ABC\") >>> len(stream) 24 >>> len(stream) // 8 3 >>> len(stream) % 8 0 BitStream.__eq__(self, other) Equality operator Usage >>> BitStream(True) == BitStream(True) True >>> BitStream(True) == BitStream([True]) True >>> BitStream(True) == BitStream(False) False >>> BitStream(True) == BitStream([True, False]) False >>> ord(b\"A\") 65 >>> BitStream(b\"A\") == BitStream(65, uint8) True >>> BitStream(b\"A\") == BitStream(66, uint8) False BitStream.__ne__(self, other) Inequality operator Usage >>> BitStream(True) != BitStream(True) False >>> BitStream(True) != BitStream([True]) False >>> BitStream(True) != BitStream(False) True >>> BitStream(True) != BitStream([True, False]) True >>> ord(b\"A\") 65 >>> BitStream(b\"A\") != BitStream(65, uint8) False >>> BitStream(b\"A\") != BitStream(66, uint8) True BitStream.__hash__(self) Compute a bitstream hash The computed hash is consistent with the equality operator. Custom Types \u00b6 User-defined binary codecs can be bound to type identifiers. For details, refer to Custom Types . register(type, reader=None, writer=None) Register a binary encoding (and/or) decoding. type is a type identifier (type or \"type tag\"). reader is a function with signature reader(stream, n=None) . writer is a function with signature writer(stream, data) . Exceptions \u00b6 ReadError Exception raised when a binary decoding is impossible. WriteError Exception raised when a binary encoding is impossible. Snapshots \u00b6 Save and restore stream states. For details, refer to Snapshots . As a user, you should not rely on the implementation of State which is an internal detail: instances of State have no public attribute, no public method, they can only be produced by save and consumed by restore . State The opaque type of stream state. BitStream.save(self) Return a State instance BitStream.restore(self, state) Restore a previous stream state. Raise a ValueError if the state is invalid.","title":"API Reference"},{"location":"API/#api-reference","text":"We assume in the sequel that all symbols of NumPy and BitStream are available: >>> from numpy import * >>> from bitstream import *","title":"API Reference"},{"location":"API/#constructor","text":"Most of the library features are available through the BitStream class: BitStream() Create an empty bitstream.","title":"Constructor"},{"location":"API/#read-write","text":"BitStream.write(self, data, type=None) Encode data and append it to the stream.","title":"Read / Write"},{"location":"API/#string-representation","text":"BitStream.__str__(self) Represent the stream as a string of '0' and '1' .","title":"String Representation"},{"location":"API/#copy","text":"Bitstreams can be copied non-destructively with BitStream.copy . They also support the interface required by the standard library copy module. BitStream.copy(self, n=None) Copy (partially or totally) the stream. Copies do not consume the stream they read.","title":"Copy"},{"location":"API/#length-and-comparison","text":"BitStream.__len__(self, other) Return the bitstream length in bits.","title":"Length and Comparison"},{"location":"API/#custom-types","text":"User-defined binary codecs can be bound to type identifiers. For details, refer to Custom Types . register(type, reader=None, writer=None) Register a binary encoding (and/or) decoding. type is a type identifier (type or \"type tag\"). reader is a function with signature reader(stream, n=None) . writer is a function with signature writer(stream, data) .","title":"Custom Types"},{"location":"API/#exceptions","text":"ReadError Exception raised when a binary decoding is impossible. WriteError Exception raised when a binary encoding is impossible.","title":"Exceptions"},{"location":"API/#snapshots","text":"Save and restore stream states. For details, refer to Snapshots . As a user, you should not rely on the implementation of State which is an internal detail: instances of State have no public attribute, no public method, they can only be produced by save and consumed by restore . State The opaque type of stream state. BitStream.save(self) Return a State instance BitStream.restore(self, state) Restore a previous stream state. Raise a ValueError if the state is invalid.","title":"Snapshots"},{"location":"contributing/","text":"Contributing \u00b6 Contributors: https://github.com/boisgera/bitstream/graphs/contributors Bitstream is developped on GitHub . To contribute, please open an issue or submit a pull request for the code or documentation. The following sections should help you to get started. Getting Started \u00b6 Follow the steps required to install from sources and make sure that you have installed all the developer dependencies ( pip install -r requirements-dev.txt ). Run the Tests \u00b6 To run all the tests, type $ python test.py If nothing happens, your version of bitstream is probably fine: all the code snippets used in the documentation have been checked by doctest and have correct outputs. To find out more about these tests, run $ python test.py -v The bitstream project uses Travis CI to run all the tests on each new commit. If you fork bitstream, make sure to activate Travis CI . To add new tests, just update the documentation . Documentation \u00b6 The documentation is built with MkDocs and its Material theme. The documentation sources are markdown files located in the mkdocs directory and assembled according to the configuration file mkdocs.yml . Build the docs 2 with $ mkdocs build This command outputs HTML documentation into the docs directory. pip install pyyaml \u21a9 For work in progress, use mkdocs serve : it creates a web server that listens on http://127.0.0.1:8000 and refreshes automatically the documentation when its source files change. \u21a9","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributors: https://github.com/boisgera/bitstream/graphs/contributors Bitstream is developped on GitHub . To contribute, please open an issue or submit a pull request for the code or documentation. The following sections should help you to get started.","title":"Contributing"},{"location":"contributing/#getting-started","text":"Follow the steps required to install from sources and make sure that you have installed all the developer dependencies ( pip install -r requirements-dev.txt ).","title":"Getting Started"},{"location":"contributing/#run-the-tests","text":"To run all the tests, type $ python test.py If nothing happens, your version of bitstream is probably fine: all the code snippets used in the documentation have been checked by doctest and have correct outputs. To find out more about these tests, run $ python test.py -v The bitstream project uses Travis CI to run all the tests on each new commit. If you fork bitstream, make sure to activate Travis CI . To add new tests, just update the documentation .","title":"Run the Tests"},{"location":"contributing/#documentation","text":"The documentation is built with MkDocs and its Material theme. The documentation sources are markdown files located in the mkdocs directory and assembled according to the configuration file mkdocs.yml . Build the docs 2 with $ mkdocs build This command outputs HTML documentation into the docs directory. pip install pyyaml \u21a9 For work in progress, use mkdocs serve : it creates a web server that listens on http://127.0.0.1:8000 and refreshes automatically the documentation when its source files change. \u21a9","title":"Documentation"},{"location":"custom/","text":"Custom Types \u00b6 This section explains how to deal with a data type or a binary coding that bitstream does not support natively: how to define bitstream writer and reader functions and register them so that your custom types behave like native ones. >>> import sys >>> import bitstream >>> from bitstream import BitStream We use the example of representation of unsigned integers as binary numbers; out of the box, bitstream only supports unsigned integers of fixed size (refer to Built-in Types / Integers for details). Definition \u00b6 For every type of data that we want bitstream to support, we need to specify at least one writer function that encodes the data as a bitstream and one reader function that decodes data out of bitstreams. The signature of writers is def writer(stream, data) where stream is a BitStream instance, the type of data is writer-dependent. A writer is totally free to specify what is a valid data , but it is sensible to accept: instances of a reference data type (or some of these instances), data that can be safely converted to the reference data type, sequences (lists, arrays, etc.) of the reference type (or assimilated). A writer should raise an exception ( ValueError or TypeError ) when the data is invalid. To write unsigned integers as binary numbers for example, we can consider as valid anything any non-negative integer-like data (defined as anything that the constructor int accepts) as well as lists of such data. >>> def write_uint(stream, data): ... if isinstance(data, list): ... for integer in data: ... write_uint(stream, integer) ... else: ... integer = int(data) ... if integer < 0: ... error = \"negative integers cannot be encoded\" ... raise ValueError(error) ... bools = [] ... while integer: ... bools.append(integer & 1) ... integer = integer >> 1 ... bools.reverse() ... stream.write(bools, bool) This writer behaves as expected: >>> stream = BitStream() >>> write_uint(stream, 42) >>> stream 101010 >>> write_uint(stream, [1, 2, 3]) >>> stream 10101011011 >>> write_uint(stream, -1) Traceback (most recent call last): ... ValueError: negative integers cannot be encoded >>> write_uint(stream, {}) # doctest: +ELLIPSIS Traceback (most recent call last): ... TypeError: int() argument must be ..., not 'dict' The signature of readers is: def reader(stream, n=None) where stream is a BitStream instance, n is a non-negative integer (or None ). The call read(stream, n) should read n data items out of stream when n is an integer. However, bitstream does not require a specific type of container (list, array, string, etc.), the choice is all yours; for consistency however, you should pick a type of container that your writer supports. The semantics of call read(stream) (when n=None ) is up to you; for most of built-in types, it returns a single (unboxed) datum of the stream but there are sometimes good reasons to decide otherwise (see for example strings ). The support for this default case is not mandatory. Actually, readers may support only a subset of the possible values of n ; for example they may allow only n=1 and n=None . If a reader is called with an invalid value of n , a ValueError or TypeError exception should be raised. If instead the read fails because there is not enough data in the stream or more generally if the binary data cannot be decoded, a ReadError (from bitstream ) should be raised. When we represent unsigned integers as binary numbers, while we can write multiple integers in the same stream, we cannot read unambiguously multiple integers from the stream: the code is not self-delimiting . For example 110 can be split as 1 then 10 and code for the integers 1 and 2 but also as 11 and 0 which represent the integers 3 and 0 . Thus, we design a reader that reads the whole stream as a single integer: we support only the cases n=1 and for convenience the default n=None with the same result. A possible implementation of this reader is: >>> def read_uint(stream, n=None): ... if n is not None and not n == 1: ... error = \"unsupported argument n = {0!r}\".format(n) ... raise ValueError(error) ... else: ... integer = 0 ... for _ in range(len(stream)): ... integer = integer << 1 ... if stream.read(bool): ... integer += 1 ... return integer It behaves as expected: >>> stream = BitStream() >>> write_uint(stream, 42) >>> read_uint(stream) 42 >>> write_uint(stream, [1, 2, 3]) >>> read_uint(stream) 27 >>> len(stream) 0 >>> write_uint(stream, 42) >>> read_uint(stream, 1) 42 >>> write_uint(stream, 42) >>> read_uint(stream, 2) Traceback (most recent call last): ... ValueError: unsupported argument n = 2 Registration \u00b6 To fully integrate unsigned integers into bitstream, you need to associate a unique type identifier to the reader and/or writer, This type identifier is usually a type; a user-defined type with an empty definition will do: >>> class uint(object): ... pass Once the type uint has been associated to the unsigned integer writer >>> bitstream.register(uint, writer=write_uint) we can use the write method of BitStream to encode unsigned integers >>> stream = BitStream() >>> stream.write(42, uint) >>> stream 101010 >>> stream = BitStream() >>> stream.write([2, 2, 2], uint) >>> stream 101010 and also the shorter former using the BitStream constructor >>> BitStream(42, uint) 101010 >>> BitStream([2, 2, 2], uint) 101010 Once the reader is registered >>> bitstream.register(uint, reader=read_uint) we can also use the read method of BitStream : >>> BitStream(42, uint).read(uint) 42 Here, the uint type was merely an identifier for our reader and writer, but \"real\" types can be used too. If you write some data whose type is the type identifier of a writer, you don't need to specify explicitly the type identifier in writes. For example, if we also associate our writer with Python integers: >>> bitstream.register(int, writer=write_uint) >>> if sys.version_info[0] == 2: # Python 2 has a 'long integer' type ... bitstream.register(long, writer=write_uint) then every Python integer will be automatically encoded with the write_uint writer >>> BitStream(42) 101010 >>> BitStream([2, 2, 2]) 101010 Factories \u00b6 The coding of arbitrary unsigned integers as binary numbers doesn't allow us to represent unambiguously multiple numbers in a stream. However, if there is a known bound on the integers we use, we can assign a sufficient numbers of bits to each integer, pad the binary numbers with enough zeros of the left to use the same number of bits and this code is self-delimiting. However, to do that, we would have to define and register a new writer for every possible number of bits. Instead, we may register a single but configurable writer, defined by a writer factory. Let's define a type identifier factory uint whose instances hold a number of bits: >>> class uint(object): ... def __init__(self, num_bits): ... self.num_bits = num_bits Then, we define a writer factory: given an instance of uint , it returns a stream writer: >>> def write_uint_factory(instance): ... num_bits = instance.num_bits ... def write_uint(stream, data): ... if isinstance(data, list): ... for integer in data: ... write_uint(stream, integer) ... else: ... integer = int(data) ... if integer < 0: ... error = \"negative integers cannot be encoded\" ... raise ValueError(error) ... bools = [] ... for _ in range(num_bits): ... bools.append(integer & 1) ... integer = integer >> 1 ... bools.reverse() ... stream.write(bools, bool) ... return write_uint Finally, we register this writer factory with bitstream : >>> bitstream.register(uint, writer=write_uint_factory) To select a writer, we use the appropriate type identifier: >>> BitStream(255, uint(8)) 11111111 >>> BitStream(255, uint(16)) 0000000011111111 >>> BitStream(42, uint(8)) 00101010 >>> BitStream(0, uint(16)) 0000000000000000 The definition of a reader factory is similar: >>> def read_uint_factory(instance): ... num_bits = instance.num_bits ... def read_uint(stream, n=None): ... if n is None: ... integer = 0 ... for _ in range(num_bits): ... integer = integer << 1 ... if stream.read(bool): ... integer += 1 ... return integer ... else: ... integers = [read_uint(stream) for _ in range(n)] ... return integers ... return read_uint Once the reader factory is registered >>> bitstream.register(uint, reader=read_uint_factory) we can use the family of type identifiers in reads too: >>> stream = BitStream([0, 1, 2, 3, 4], uint(8)) >>> stream.read(uint(8)) 0 >>> stream.read(uint(8), 1) [1] >>> stream.read(uint(8), 3) [2, 3, 4]","title":"Custom Types"},{"location":"custom/#custom-types","text":"This section explains how to deal with a data type or a binary coding that bitstream does not support natively: how to define bitstream writer and reader functions and register them so that your custom types behave like native ones. >>> import sys >>> import bitstream >>> from bitstream import BitStream We use the example of representation of unsigned integers as binary numbers; out of the box, bitstream only supports unsigned integers of fixed size (refer to Built-in Types / Integers for details).","title":"Custom Types"},{"location":"custom/#definition","text":"For every type of data that we want bitstream to support, we need to specify at least one writer function that encodes the data as a bitstream and one reader function that decodes data out of bitstreams. The signature of writers is def writer(stream, data) where stream is a BitStream instance, the type of data is writer-dependent. A writer is totally free to specify what is a valid data , but it is sensible to accept: instances of a reference data type (or some of these instances), data that can be safely converted to the reference data type, sequences (lists, arrays, etc.) of the reference type (or assimilated). A writer should raise an exception ( ValueError or TypeError ) when the data is invalid. To write unsigned integers as binary numbers for example, we can consider as valid anything any non-negative integer-like data (defined as anything that the constructor int accepts) as well as lists of such data. >>> def write_uint(stream, data): ... if isinstance(data, list): ... for integer in data: ... write_uint(stream, integer) ... else: ... integer = int(data) ... if integer < 0: ... error = \"negative integers cannot be encoded\" ... raise ValueError(error) ... bools = [] ... while integer: ... bools.append(integer & 1) ... integer = integer >> 1 ... bools.reverse() ... stream.write(bools, bool) This writer behaves as expected: >>> stream = BitStream() >>> write_uint(stream, 42) >>> stream 101010 >>> write_uint(stream, [1, 2, 3]) >>> stream 10101011011 >>> write_uint(stream, -1) Traceback (most recent call last): ... ValueError: negative integers cannot be encoded >>> write_uint(stream, {}) # doctest: +ELLIPSIS Traceback (most recent call last): ... TypeError: int() argument must be ..., not 'dict' The signature of readers is: def reader(stream, n=None) where stream is a BitStream instance, n is a non-negative integer (or None ). The call read(stream, n) should read n data items out of stream when n is an integer. However, bitstream does not require a specific type of container (list, array, string, etc.), the choice is all yours; for consistency however, you should pick a type of container that your writer supports. The semantics of call read(stream) (when n=None ) is up to you; for most of built-in types, it returns a single (unboxed) datum of the stream but there are sometimes good reasons to decide otherwise (see for example strings ). The support for this default case is not mandatory. Actually, readers may support only a subset of the possible values of n ; for example they may allow only n=1 and n=None . If a reader is called with an invalid value of n , a ValueError or TypeError exception should be raised. If instead the read fails because there is not enough data in the stream or more generally if the binary data cannot be decoded, a ReadError (from bitstream ) should be raised. When we represent unsigned integers as binary numbers, while we can write multiple integers in the same stream, we cannot read unambiguously multiple integers from the stream: the code is not self-delimiting . For example 110 can be split as 1 then 10 and code for the integers 1 and 2 but also as 11 and 0 which represent the integers 3 and 0 . Thus, we design a reader that reads the whole stream as a single integer: we support only the cases n=1 and for convenience the default n=None with the same result. A possible implementation of this reader is: >>> def read_uint(stream, n=None): ... if n is not None and not n == 1: ... error = \"unsupported argument n = {0!r}\".format(n) ... raise ValueError(error) ... else: ... integer = 0 ... for _ in range(len(stream)): ... integer = integer << 1 ... if stream.read(bool): ... integer += 1 ... return integer It behaves as expected: >>> stream = BitStream() >>> write_uint(stream, 42) >>> read_uint(stream) 42 >>> write_uint(stream, [1, 2, 3]) >>> read_uint(stream) 27 >>> len(stream) 0 >>> write_uint(stream, 42) >>> read_uint(stream, 1) 42 >>> write_uint(stream, 42) >>> read_uint(stream, 2) Traceback (most recent call last): ... ValueError: unsupported argument n = 2","title":"Definition"},{"location":"custom/#registration","text":"To fully integrate unsigned integers into bitstream, you need to associate a unique type identifier to the reader and/or writer, This type identifier is usually a type; a user-defined type with an empty definition will do: >>> class uint(object): ... pass Once the type uint has been associated to the unsigned integer writer >>> bitstream.register(uint, writer=write_uint) we can use the write method of BitStream to encode unsigned integers >>> stream = BitStream() >>> stream.write(42, uint) >>> stream 101010 >>> stream = BitStream() >>> stream.write([2, 2, 2], uint) >>> stream 101010 and also the shorter former using the BitStream constructor >>> BitStream(42, uint) 101010 >>> BitStream([2, 2, 2], uint) 101010 Once the reader is registered >>> bitstream.register(uint, reader=read_uint) we can also use the read method of BitStream : >>> BitStream(42, uint).read(uint) 42 Here, the uint type was merely an identifier for our reader and writer, but \"real\" types can be used too. If you write some data whose type is the type identifier of a writer, you don't need to specify explicitly the type identifier in writes. For example, if we also associate our writer with Python integers: >>> bitstream.register(int, writer=write_uint) >>> if sys.version_info[0] == 2: # Python 2 has a 'long integer' type ... bitstream.register(long, writer=write_uint) then every Python integer will be automatically encoded with the write_uint writer >>> BitStream(42) 101010 >>> BitStream([2, 2, 2]) 101010","title":"Registration"},{"location":"custom/#factories","text":"The coding of arbitrary unsigned integers as binary numbers doesn't allow us to represent unambiguously multiple numbers in a stream. However, if there is a known bound on the integers we use, we can assign a sufficient numbers of bits to each integer, pad the binary numbers with enough zeros of the left to use the same number of bits and this code is self-delimiting. However, to do that, we would have to define and register a new writer for every possible number of bits. Instead, we may register a single but configurable writer, defined by a writer factory. Let's define a type identifier factory uint whose instances hold a number of bits: >>> class uint(object): ... def __init__(self, num_bits): ... self.num_bits = num_bits Then, we define a writer factory: given an instance of uint , it returns a stream writer: >>> def write_uint_factory(instance): ... num_bits = instance.num_bits ... def write_uint(stream, data): ... if isinstance(data, list): ... for integer in data: ... write_uint(stream, integer) ... else: ... integer = int(data) ... if integer < 0: ... error = \"negative integers cannot be encoded\" ... raise ValueError(error) ... bools = [] ... for _ in range(num_bits): ... bools.append(integer & 1) ... integer = integer >> 1 ... bools.reverse() ... stream.write(bools, bool) ... return write_uint Finally, we register this writer factory with bitstream : >>> bitstream.register(uint, writer=write_uint_factory) To select a writer, we use the appropriate type identifier: >>> BitStream(255, uint(8)) 11111111 >>> BitStream(255, uint(16)) 0000000011111111 >>> BitStream(42, uint(8)) 00101010 >>> BitStream(0, uint(16)) 0000000000000000 The definition of a reader factory is similar: >>> def read_uint_factory(instance): ... num_bits = instance.num_bits ... def read_uint(stream, n=None): ... if n is None: ... integer = 0 ... for _ in range(num_bits): ... integer = integer << 1 ... if stream.read(bool): ... integer += 1 ... return integer ... else: ... integers = [read_uint(stream) for _ in range(n)] ... return integers ... return read_uint Once the reader factory is registered >>> bitstream.register(uint, reader=read_uint_factory) we can use the family of type identifiers in reads too: >>> stream = BitStream([0, 1, 2, 3, 4], uint(8)) >>> stream.read(uint(8)) 0 >>> stream.read(uint(8), 1) [1] >>> stream.read(uint(8), 3) [2, 3, 4]","title":"Factories"},{"location":"examples/","text":"Examples \u00b6 We provide the following examples of bitstream usage: Spoon : build a translator between Brainfuck programs and Spoon programs. Wave : synthesize a pure tone and generate the corresponding WAVE audio file. But first, as usual, let's start with >>> from bitstream import BitStream Spoon \u00b6 Spoon is a derivative of the Brainfuck programming language. Instead of the 8 ASCII symbols used by Brainfuck, it relies on binary sequences to represent each instruction. The source of the \"Hello World!\" program in Brainfuck is 1 : >>> hello_world = \"++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.\" The conversion between Brainfuck and Spoon is given by the table: >>> spoon = { ... \"+\": \"1\", ... \"-\": \"000\", ... \">\": \"010\", ... \"<\": \"011\", ... \"[\": \"00100\", ... \"]\": \"0011\", ... \".\": \"001010\", ... \",\": \"0010110\", ... } You may notice that the binary codes that correspond to symbols that frequently appear in the hello_world program (such as + ) are shorter than the others, a nice property since it generates a compact representation of Spoon programs 2 . To create a bitstream that contains the Spoon translation of hello_world , we may for each symbol in this program find the corresponding binary code in the spoon table, transform it into a list of bools and append this data to the stream. >>> stream = BitStream() >>> for symbol in hello_world: ... code = spoon[symbol] ... code_as_bools = [bool(int(char)) for char in code] ... stream.write(code_as_bools) Here is the result: >>> stream 11111111110010001011111110101111111111010111010101101101101100000110101100101001010010101111111001010001010111001010010110010100110111111111111111110010100100010101110010100000000000000000000010100000000000000000000000000010100101001010010001010 >>> len(hello_world) * 8 888 >>> len(stream) 245 We now have of program of 245 bits instead of the 888 bits (111 bytes) of the original ASCII program. Not bad ... It's also pretty easy to perform the opposite operation, to translate Spoon into Brainfuck. First, we can compute noops , the inverse of the spoon dictionary. >>> noops = {} >>> for symbol, code in spoon.items(): ... noops[code] = symbol >>> n = max(len(code) for code in noops) Then we read bits one by one from the stream into a buffer and look at each stage if the buffer corresponds to a key in noops , translate this code, empty the buffer and start again 3 . >>> src = \"\" >>> buffer = BitStream() >>> while len(stream) > 0: ... if len(buffer) > n: ... raise ValueError(\"invalid Spoon bitstream\") ... else: ... buffer.write(stream.read(bool)) ... try: ... src += noops[str(buffer)] ... buffer = BitStream() ... except KeyError: ... pass >>> if len(buffer) > 0: # should be empty by now ... raise ValueError(\"invalid Spoon bitstream\") We can then check that src and hello_world are the same program: >>> src == hello_world True Wave \u00b6 What does it take to play a pure tone? The synthesis of the data is quite easy: in the realm of digital audio, sounds are just numbers and NumPy is up to the task. The painful, low-level part of the process is to actually generate an audio file in a format that your computer does understand. Fortunately, this is where bitstream can help 4 . Most of the audio file formats that you may know (MP3, AAC, FLAC, ALAC, etc.) use compression to reduce file size; unfortunately this feature leads to rather complex formats. Therefore, we are going to output WAVE files instead, which are typically uncompressed. The WAVE PCM soundfile format webpage 5 is a great source of information about the format. We will use it to design our code; please have a look at it! Here is its high-level description: The WAVE file format is a subset of Microsoft's RIFF specification for the storage of multimedia files. A RIFF file starts out with a file header followed by a sequence of data chunks. A WAVE file is often just a RIFF file with a single \"WAVE\" chunk which consists of two sub-chunks -- a \"fmt \" chunk specifying the data format and a \"data\" chunk containing the actual sample data. First, we import NumPy (and globally the integer types that we need). >>> import numpy as np >>> from numpy import uint8, uint16, uint32, int16 We use NumPy to produce 3 seconds of a pure tone with frequency 440 Hz (A4) at a sampling rate of 44.1 kHz (the audio CD standard). >>> # Generate a waveform (pure tone) >>> df = 44100 >>> dt = 1.0 / df >>> T = 3.0 >>> t = np.r_[0.0:T:dt] >>> f = 440.0 >>> data = np.sin(2 * np.pi * f * t) In this description, every sample is a floating-point number that requires 64 bits. The typical WAVE file requires 16-bit integer data instead, so we perform the (lossy) conversion: >>> # Quantize the floating-point data >>> ones_ = np.ones_like(data) >>> low = (-2**15 ) * ones_ >>> high = ( 2**15 - 1) * ones_ >>> data = np.clip(2**15 * data, low, high) >>> data = np.round(data).astype(np.int16) Since WAVE files use a little-endian representation every numeric value and since bitstream is big-endian by default, we define a small function to help us perform the change automatically, using the newbyteorder method of NumPy. >>> # Stream endianness helper >>> stream = BitStream() >>> def write(datum, type=None): ... if type and issubclass(type, np.integer): ... datum = type(datum).newbyteorder() ... stream.write(datum, type) The rest of the work is a straightforward translation of the specification : first we write the main chunk >>> # \"RIFF\" Chunk Descriptor >>> chunk_size = 36 + 2 * len(data) # size of the chunk after \"RIFF\" >>> >>> write(b\"RIFF\" ) >>> write(chunk_size, uint32) >>> write(b\"WAVE\" ) then the format subchunk >>> # \"fmt\" SubChunk >>> subchunk1_size = 16 # size in bytes of the subchunk after \"fmt \" >>> audio_format = 1 # PCM data >>> num_channels = 1 # mono >>> byte_rate = 2 * df >>> block_align = 2 # number of bytes for one sample (all channels) >>> bits_per_sample = 16 >>> >>> write(b\"fmt \" ) >>> write(subchunk1_size , uint32) >>> write(audio_format , uint16) >>> write(num_channels , uint16) >>> write(df , uint32) >>> write(byte_rate , uint32) >>> write(block_align , uint16) >>> write(bits_per_sample, uint16) and finally the data subchunk >>> # \"data\" SubChunk >>> subchunk2_size = 2 * len(data) # size in bytes of the subchunk after \"data\" >>> >>> write(b\"data\" ) >>> write(subchunk2_size, uint32) >>> write(data , int16) and that's it! stream holds the content of our WAVE file; all we have to do is to read it as a string that we write into an actual file. >>> # Generate the WAVE file >>> wave_bytes = stream.read(bytes) >>> wave_file = open(\"output.wav\", \"wb\") >>> _ = wave_file.write(wave_bytes) You can now listen to the sound in output.wav with your favorite music player. For the sake of consistency, let's make sure that you and I have the same contents: >>> import hashlib >>> m = hashlib.md5() >>> m.update(wave_bytes) >>> m.digest() # doctest: +BYTES b'\\xb0\\xcf\\x0e8\\x150\\x1fV \\x86\\x9e2\\xdf\\xfb\\x1d\\xec' You don't have to trust me on this, you may try this code online at https://copy.sh/brainfuck/ . \u21a9 This is not a coincidence: Spoon has been designed as a Huffman code based on the analysis of a representative collection of Brainfuck programs. \u21a9 This approach -- without any lookahead -- is safe here because this code is prefix-free . \u21a9 Of course, there is a module in the Python standard library to read and write WAV files . We just pretend that we're in the mood to reinvent this wheel and learn something in the process. \u21a9 by Craig Sapp from the Center for Computer Research in Music and Acoustics : \u21a9","title":"Examples"},{"location":"examples/#examples","text":"We provide the following examples of bitstream usage: Spoon : build a translator between Brainfuck programs and Spoon programs. Wave : synthesize a pure tone and generate the corresponding WAVE audio file. But first, as usual, let's start with >>> from bitstream import BitStream","title":"Examples"},{"location":"examples/#spoon","text":"Spoon is a derivative of the Brainfuck programming language. Instead of the 8 ASCII symbols used by Brainfuck, it relies on binary sequences to represent each instruction. The source of the \"Hello World!\" program in Brainfuck is 1 : >>> hello_world = \"++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.\" The conversion between Brainfuck and Spoon is given by the table: >>> spoon = { ... \"+\": \"1\", ... \"-\": \"000\", ... \">\": \"010\", ... \"<\": \"011\", ... \"[\": \"00100\", ... \"]\": \"0011\", ... \".\": \"001010\", ... \",\": \"0010110\", ... } You may notice that the binary codes that correspond to symbols that frequently appear in the hello_world program (such as + ) are shorter than the others, a nice property since it generates a compact representation of Spoon programs 2 . To create a bitstream that contains the Spoon translation of hello_world , we may for each symbol in this program find the corresponding binary code in the spoon table, transform it into a list of bools and append this data to the stream. >>> stream = BitStream() >>> for symbol in hello_world: ... code = spoon[symbol] ... code_as_bools = [bool(int(char)) for char in code] ... stream.write(code_as_bools) Here is the result: >>> stream 11111111110010001011111110101111111111010111010101101101101100000110101100101001010010101111111001010001010111001010010110010100110111111111111111110010100100010101110010100000000000000000000010100000000000000000000000000010100101001010010001010 >>> len(hello_world) * 8 888 >>> len(stream) 245 We now have of program of 245 bits instead of the 888 bits (111 bytes) of the original ASCII program. Not bad ... It's also pretty easy to perform the opposite operation, to translate Spoon into Brainfuck. First, we can compute noops , the inverse of the spoon dictionary. >>> noops = {} >>> for symbol, code in spoon.items(): ... noops[code] = symbol >>> n = max(len(code) for code in noops) Then we read bits one by one from the stream into a buffer and look at each stage if the buffer corresponds to a key in noops , translate this code, empty the buffer and start again 3 . >>> src = \"\" >>> buffer = BitStream() >>> while len(stream) > 0: ... if len(buffer) > n: ... raise ValueError(\"invalid Spoon bitstream\") ... else: ... buffer.write(stream.read(bool)) ... try: ... src += noops[str(buffer)] ... buffer = BitStream() ... except KeyError: ... pass >>> if len(buffer) > 0: # should be empty by now ... raise ValueError(\"invalid Spoon bitstream\") We can then check that src and hello_world are the same program: >>> src == hello_world True","title":"Spoon"},{"location":"examples/#wave","text":"What does it take to play a pure tone? The synthesis of the data is quite easy: in the realm of digital audio, sounds are just numbers and NumPy is up to the task. The painful, low-level part of the process is to actually generate an audio file in a format that your computer does understand. Fortunately, this is where bitstream can help 4 . Most of the audio file formats that you may know (MP3, AAC, FLAC, ALAC, etc.) use compression to reduce file size; unfortunately this feature leads to rather complex formats. Therefore, we are going to output WAVE files instead, which are typically uncompressed. The WAVE PCM soundfile format webpage 5 is a great source of information about the format. We will use it to design our code; please have a look at it! Here is its high-level description: The WAVE file format is a subset of Microsoft's RIFF specification for the storage of multimedia files. A RIFF file starts out with a file header followed by a sequence of data chunks. A WAVE file is often just a RIFF file with a single \"WAVE\" chunk which consists of two sub-chunks -- a \"fmt \" chunk specifying the data format and a \"data\" chunk containing the actual sample data. First, we import NumPy (and globally the integer types that we need). >>> import numpy as np >>> from numpy import uint8, uint16, uint32, int16 We use NumPy to produce 3 seconds of a pure tone with frequency 440 Hz (A4) at a sampling rate of 44.1 kHz (the audio CD standard). >>> # Generate a waveform (pure tone) >>> df = 44100 >>> dt = 1.0 / df >>> T = 3.0 >>> t = np.r_[0.0:T:dt] >>> f = 440.0 >>> data = np.sin(2 * np.pi * f * t) In this description, every sample is a floating-point number that requires 64 bits. The typical WAVE file requires 16-bit integer data instead, so we perform the (lossy) conversion: >>> # Quantize the floating-point data >>> ones_ = np.ones_like(data) >>> low = (-2**15 ) * ones_ >>> high = ( 2**15 - 1) * ones_ >>> data = np.clip(2**15 * data, low, high) >>> data = np.round(data).astype(np.int16) Since WAVE files use a little-endian representation every numeric value and since bitstream is big-endian by default, we define a small function to help us perform the change automatically, using the newbyteorder method of NumPy. >>> # Stream endianness helper >>> stream = BitStream() >>> def write(datum, type=None): ... if type and issubclass(type, np.integer): ... datum = type(datum).newbyteorder() ... stream.write(datum, type) The rest of the work is a straightforward translation of the specification : first we write the main chunk >>> # \"RIFF\" Chunk Descriptor >>> chunk_size = 36 + 2 * len(data) # size of the chunk after \"RIFF\" >>> >>> write(b\"RIFF\" ) >>> write(chunk_size, uint32) >>> write(b\"WAVE\" ) then the format subchunk >>> # \"fmt\" SubChunk >>> subchunk1_size = 16 # size in bytes of the subchunk after \"fmt \" >>> audio_format = 1 # PCM data >>> num_channels = 1 # mono >>> byte_rate = 2 * df >>> block_align = 2 # number of bytes for one sample (all channels) >>> bits_per_sample = 16 >>> >>> write(b\"fmt \" ) >>> write(subchunk1_size , uint32) >>> write(audio_format , uint16) >>> write(num_channels , uint16) >>> write(df , uint32) >>> write(byte_rate , uint32) >>> write(block_align , uint16) >>> write(bits_per_sample, uint16) and finally the data subchunk >>> # \"data\" SubChunk >>> subchunk2_size = 2 * len(data) # size in bytes of the subchunk after \"data\" >>> >>> write(b\"data\" ) >>> write(subchunk2_size, uint32) >>> write(data , int16) and that's it! stream holds the content of our WAVE file; all we have to do is to read it as a string that we write into an actual file. >>> # Generate the WAVE file >>> wave_bytes = stream.read(bytes) >>> wave_file = open(\"output.wav\", \"wb\") >>> _ = wave_file.write(wave_bytes) You can now listen to the sound in output.wav with your favorite music player. For the sake of consistency, let's make sure that you and I have the same contents: >>> import hashlib >>> m = hashlib.md5() >>> m.update(wave_bytes) >>> m.digest() # doctest: +BYTES b'\\xb0\\xcf\\x0e8\\x150\\x1fV \\x86\\x9e2\\xdf\\xfb\\x1d\\xec' You don't have to trust me on this, you may try this code online at https://copy.sh/brainfuck/ . \u21a9 This is not a coincidence: Spoon has been designed as a Huffman code based on the analysis of a representative collection of Brainfuck programs. \u21a9 This approach -- without any lookahead -- is safe here because this code is prefix-free . \u21a9 Of course, there is a module in the Python standard library to read and write WAV files . We just pretend that we're in the mood to reinvent this wheel and learn something in the process. \u21a9 by Craig Sapp from the Center for Computer Research in Music and Acoustics : \u21a9","title":"Wave"},{"location":"installation/","text":"Bitstream supports Python 2.7 and 3.6 to 3.9 on Linux, Windows and MacOS. We recommend you to install bitstream with pip. If for some reason that doesn't work for you -- for example if you want to modify the software -- you can also install bitstream from sources. Install with Pip \u00b6 Check the following prerequisites Pip The pip package installer should be available $ pip --version pip 9.0.1 from /usr/local/lib/python3.6/dist-packages (python 3.6) Otherwise follow these instructions . NumPy Bitstream depends on the NumPy package; install it if necessary: $ pip install numpy C compiler You need a compiler which can work with pip and your version of Python. On Windows, for Python 2.7 you can install the Microsoft Visual C++ Compiler for Python 2.7 . For Python 3, a recent Visual Studio compiler (2015 or later) should work; you may for example install Visual Studio Community . then install bitstream: $ pip install bitstream Install from Sources \u00b6 Download the Sources \u00b6 First, download the sources with git and enter the project directory: $ git clone https://github.com/boisgera/bitstream $ cd bitstream Alternatively, you can also download the project ZIP archive . For example: $ wget https://github.com/boisgera/bitstream/archive/master.zip $ unzip master.zip $ cd bitstream-master Required Tools \u00b6 Building from sources requires everything you need for a pip-based install and more. Since bitstream is written in Cython , at the very least you need a Cython compiler . If you don't mind having a few extra packags installed, it's easier to install all developer dependencies with: $ pip install -r requirements-dev.txt Build and Install \u00b6 Run the command: $ python setup.py --cython install If you want to do more than just build bitstream from sources -- for example run the tests, regenerate the documentation, etc. -- please refer to the Contributing section . Troubleshooting \u00b6 The command python setup.py install doesn't work This is expected: this command needs C files to build bitstream, which is a Python C extension module, but these files are not present in the git repository. They have first to be generated by the Cython compiler from the .pyx and .pxd files with: $ python setup.py --cython build To \"solve\" this issue, you can make the --cython option implicit with a setup.cfg file that contains: [global] cython = 1","title":"Installation"},{"location":"installation/#install-with-pip","text":"Check the following prerequisites Pip The pip package installer should be available $ pip --version pip 9.0.1 from /usr/local/lib/python3.6/dist-packages (python 3.6) Otherwise follow these instructions . NumPy Bitstream depends on the NumPy package; install it if necessary: $ pip install numpy C compiler You need a compiler which can work with pip and your version of Python. On Windows, for Python 2.7 you can install the Microsoft Visual C++ Compiler for Python 2.7 . For Python 3, a recent Visual Studio compiler (2015 or later) should work; you may for example install Visual Studio Community . then install bitstream: $ pip install bitstream","title":"Install with Pip"},{"location":"installation/#install-from-sources","text":"","title":"Install from Sources"},{"location":"installation/#download-the-sources","text":"First, download the sources with git and enter the project directory: $ git clone https://github.com/boisgera/bitstream $ cd bitstream Alternatively, you can also download the project ZIP archive . For example: $ wget https://github.com/boisgera/bitstream/archive/master.zip $ unzip master.zip $ cd bitstream-master","title":"Download the Sources"},{"location":"installation/#required-tools","text":"Building from sources requires everything you need for a pip-based install and more. Since bitstream is written in Cython , at the very least you need a Cython compiler . If you don't mind having a few extra packags installed, it's easier to install all developer dependencies with: $ pip install -r requirements-dev.txt","title":"Required Tools"},{"location":"installation/#build-and-install","text":"Run the command: $ python setup.py --cython install If you want to do more than just build bitstream from sources -- for example run the tests, regenerate the documentation, etc. -- please refer to the Contributing section .","title":"Build and Install"},{"location":"installation/#troubleshooting","text":"The command python setup.py install doesn't work This is expected: this command needs C files to build bitstream, which is a Python C extension module, but these files are not present in the git repository. They have first to be generated by the Cython compiler from the .pyx and .pxd files with: $ python setup.py --cython build To \"solve\" this issue, you can make the --cython option implicit with a setup.cfg file that contains: [global] cython = 1","title":"Troubleshooting"},{"location":"overview/","text":"Overview \u00b6 Bitstream is a Python library which manages binary data as bit streams. Binary Data: the BitStream class is a linearly ordered container of bits. The standard library is only convenient to manage binary data at the byte level. Consider using BitStream instead, especially you need to address the bit level. Stream Interface: you can only read data at the start of a stream and write data at its end. This is a very simple way to interact with binary data, but it is also the pattern that comes naturally in many applications. To manage binary codes and formats, in my experience, random data access is not a requirement. Python and Numpy Types. BitStream has built-in readers and writers for the common data types with a standard binary layout: bools, ASCII strings, fixed-size integers and floating-point integers. User-Defined Types. The list of supported types and binary representation may be enlarged at will: new readers and writers can be implemented and associated to specific data types. Performance. Bitstream is a Python C-extension module that has been optimized for the common use cases. Hopefully, it will be fast enough for your needs ! Under the hood, the Cython language and compiler are used to generate this extension module. Open-Source. Bitstream is distributed under a MIT license . The development takes place on GitHub and releases are available on PyPI .","title":"Overview"},{"location":"overview/#overview","text":"Bitstream is a Python library which manages binary data as bit streams. Binary Data: the BitStream class is a linearly ordered container of bits. The standard library is only convenient to manage binary data at the byte level. Consider using BitStream instead, especially you need to address the bit level. Stream Interface: you can only read data at the start of a stream and write data at its end. This is a very simple way to interact with binary data, but it is also the pattern that comes naturally in many applications. To manage binary codes and formats, in my experience, random data access is not a requirement. Python and Numpy Types. BitStream has built-in readers and writers for the common data types with a standard binary layout: bools, ASCII strings, fixed-size integers and floating-point integers. User-Defined Types. The list of supported types and binary representation may be enlarged at will: new readers and writers can be implemented and associated to specific data types. Performance. Bitstream is a Python C-extension module that has been optimized for the common use cases. Hopefully, it will be fast enough for your needs ! Under the hood, the Cython language and compiler are used to generate this extension module. Open-Source. Bitstream is distributed under a MIT license . The development takes place on GitHub and releases are available on PyPI .","title":"Overview"},{"location":"snapshots/","text":"Snapshots \u00b6 A stream is a simple model to deal with binary data, but sometimes you need more: you want to perform some lookahead without changing the stream or you want to try some read/write operations but go back to the initial state if they fail. At this stage, you probably have copies of streams everywhere and the stream interface seems very cumbersome. Therefore, we provide snapshots, a simple solution for these use cases that doesn't require copies of streams: you can save the state of a stream at any stage in a sequence of read/write operations and restore any such state later if you need it. Lookahead \u00b6 The type of binary data can usually be identified by a specific header coded in its first few bytes. For example, WAVE audio can be detected with the function: >>> from bitstream import BitStream, ReadError >>> def is_wave(stream): ... try: ... riff = stream.read(bytes, 4) ... _ = stream.read(bytes, 4) ... wave = stream.read(bytes, 4) ... return (riff == b\"RIFF\") and (wave == b\"WAVE\") ... except ReadError: ... return False The contents of an empty single-channel 44.1 kHz WAVE audio file are for example >>> wave = b'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00' The function is_wave above works as expected at first >>> stream = BitStream(wave) >>> is_wave(stream) True but another attempt gives an incorrect answer: >>> is_wave(stream) False The explanation is simple: to identify the header of a WAVE file, we need to consume the first 12 bytes in the stream. Since this header is missing from the stream afterwards, the new attempt fails. To solve this issue, it's possible to make is_wave perform a (partial) copy of the stream and perform the check on the copy, leaving the initial stream unchanged. However in general this approach may be cumbersome; copies should also be avoided when possible for performance reasons. Bitstream also supports snapshots, a better way to deal with lookaheads. With them you can: save the state of a stream at any time, perform arbitrary operations on it and then restore its initial state. The implementation of is_wave that does this is plain; we just make sure that whatever happens (even an error in the processing) the original state of the stream is restored at the end. >>> def is_wave(stream): ... snapshot = stream.save() ... try: ... riff = stream.read(bytes, 4) ... _ = stream.read(bytes, 4) ... wave = stream.read(bytes, 4) ... return (riff == b\"RIFF\") and (wave == b\"WAVE\") ... except ReadError: ... return False ... finally: ... stream.restore(snapshot) This version works as expected: >>> wave = b'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00' >>> stream = BitStream(wave) >>> copy = stream.copy() >>> is_wave(stream) True >>> stream == copy True >>> is_wave(stream) True Exception Safety \u00b6 Consider the toy DNA reader below: >>> def DNA_read(stream, n=1): ... DNA_bases = b\"ACGT\" ... bases = [] ... for i in range(n): ... base = stream.read(bytes, 1) ... if base not in DNA_bases: ... error = \"invalid base {0!r}\".format(base) ... raise ReadError(error) ... else: ... bases.append(base) ... return b\"\".join(bases) It reads DNA sequences represented as bytes, either b'A' , b'C' , b'G' or b'T' : >>> dna = BitStream(b\"GATA\") >>> DNA_read(dna, 4) # doctest: +BYTES b'GATA' If there is a 'U' in the sequence, this is an error since the uracil base is only found in RNA. >>> stream = BitStream(b\"GAUTA\") # invalid DNA sequence The DNA reader correctly rejects the code >>> try: ... DNA_read(stream, 4) ... except ReadError: ... print(\"Read error\") Read error but the initial stream is partially consumed in the process: >>> stream.read(bytes) # doctest: +BYTES b'TA' This implementation therefore only provides some basic exception safety. A reader that preserves the original value of the stream when an error occurs would provide strong exception safety instead. With snapshots, the modifications required to support this are plain: we simply restore the original stream whenever an error occurs >>> def DNA_read(stream, n=1): ... DNA_bases = b\"ACGT\" ... snapshot = stream.save() ... try: ... bases = [] ... for i in range(n): ... base = stream.read(bytes, 1) ... if base not in DNA_bases: ... error = \"invalid base {0!r}\".format(base) ... raise ReadError(error) ... else: ... bases.append(base) ... return \"\".join(bases) ... except: ... stream.restore(snapshot) ... raise With this new version, reading an invalid DNA code still raises an exception >>> stream = BitStream(b\"GAUTA\") # invalid DNA sequence >>> try: ... DNA_read(stream, 4) ... except ReadError: ... print(\"Read error\") Read error but now the original stream is intact >>> stream.read(bytes) # doctest: +BYTES b'GAUTA' Multiple Snapshots \u00b6 You can create snapshots of a stream at any stage between read/write operations. Multiple snapshots enable for example the implemention a hierarchy of readers or writers that provide strong exception safety at every level. However arbitrary sequences of save and restore are not allowed: when a given snapshot is restored, the snapshots that were created between the snapshot creation and before its restoration are forgotten. In other words, saves and restores can only be applied in reverse order. Of course it is perfectly valid to skip some of the restores in the process: you can always create additional snapshots and never use them. For example, you can take two snapshots s0 then s1 of a stream between write operations >>> stream = BitStream() >>> s0 = stream.save() >>> stream.write(b\"A\") >>> s1 = stream.save() >>> stream.write(b\"B\") >>> stream == BitStream(b\"AB\") True restore s1 >>> stream.restore(s1) >>> stream == BitStream(b\"A\") True and then s0 >>> stream.restore(s0) >>> stream == BitStream(b\"\") True You can also make the same snapshots >>> stream = BitStream() >>> s0 = stream.save() >>> stream.write(b\"A\") >>> s1 = stream.save() >>> stream.write(b\"B\") >>> stream == BitStream(b\"AB\") True and directly restore s0 >>> stream.restore(s0) >>> stream == BitStream(b\"\") True but then s1 cannot be used anymore >>> stream.restore(s1) # doctest: +ELLIPSIS Traceback (most recent call last): ... ValueError: ... How does it Work? \u00b6 The main (private) attributes of a BitStream structure are: an array of bytes: the raw data read and write cursors: they locate the beginning and the end of the stream in the bytes array. When you read data from a stream, you shift the read cursor but the corresponding data is not deleted 1 -- its is merely not accessible. The State structure stores values of the read and write cursors; the call state = stream.save() produces a snapshot of the current cursor locations and stream.restore(state) restores them. This is why the memory consumption increases if you write a lot of data into a stream, even if you read it! The solution in this case is to copy the stream and discard the original since the copy method discards write history. \u21a9","title":"Snapshots"},{"location":"snapshots/#snapshots","text":"A stream is a simple model to deal with binary data, but sometimes you need more: you want to perform some lookahead without changing the stream or you want to try some read/write operations but go back to the initial state if they fail. At this stage, you probably have copies of streams everywhere and the stream interface seems very cumbersome. Therefore, we provide snapshots, a simple solution for these use cases that doesn't require copies of streams: you can save the state of a stream at any stage in a sequence of read/write operations and restore any such state later if you need it.","title":"Snapshots"},{"location":"snapshots/#lookahead","text":"The type of binary data can usually be identified by a specific header coded in its first few bytes. For example, WAVE audio can be detected with the function: >>> from bitstream import BitStream, ReadError >>> def is_wave(stream): ... try: ... riff = stream.read(bytes, 4) ... _ = stream.read(bytes, 4) ... wave = stream.read(bytes, 4) ... return (riff == b\"RIFF\") and (wave == b\"WAVE\") ... except ReadError: ... return False The contents of an empty single-channel 44.1 kHz WAVE audio file are for example >>> wave = b'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00' The function is_wave above works as expected at first >>> stream = BitStream(wave) >>> is_wave(stream) True but another attempt gives an incorrect answer: >>> is_wave(stream) False The explanation is simple: to identify the header of a WAVE file, we need to consume the first 12 bytes in the stream. Since this header is missing from the stream afterwards, the new attempt fails. To solve this issue, it's possible to make is_wave perform a (partial) copy of the stream and perform the check on the copy, leaving the initial stream unchanged. However in general this approach may be cumbersome; copies should also be avoided when possible for performance reasons. Bitstream also supports snapshots, a better way to deal with lookaheads. With them you can: save the state of a stream at any time, perform arbitrary operations on it and then restore its initial state. The implementation of is_wave that does this is plain; we just make sure that whatever happens (even an error in the processing) the original state of the stream is restored at the end. >>> def is_wave(stream): ... snapshot = stream.save() ... try: ... riff = stream.read(bytes, 4) ... _ = stream.read(bytes, 4) ... wave = stream.read(bytes, 4) ... return (riff == b\"RIFF\") and (wave == b\"WAVE\") ... except ReadError: ... return False ... finally: ... stream.restore(snapshot) This version works as expected: >>> wave = b'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00' >>> stream = BitStream(wave) >>> copy = stream.copy() >>> is_wave(stream) True >>> stream == copy True >>> is_wave(stream) True","title":"Lookahead"},{"location":"snapshots/#exception-safety","text":"Consider the toy DNA reader below: >>> def DNA_read(stream, n=1): ... DNA_bases = b\"ACGT\" ... bases = [] ... for i in range(n): ... base = stream.read(bytes, 1) ... if base not in DNA_bases: ... error = \"invalid base {0!r}\".format(base) ... raise ReadError(error) ... else: ... bases.append(base) ... return b\"\".join(bases) It reads DNA sequences represented as bytes, either b'A' , b'C' , b'G' or b'T' : >>> dna = BitStream(b\"GATA\") >>> DNA_read(dna, 4) # doctest: +BYTES b'GATA' If there is a 'U' in the sequence, this is an error since the uracil base is only found in RNA. >>> stream = BitStream(b\"GAUTA\") # invalid DNA sequence The DNA reader correctly rejects the code >>> try: ... DNA_read(stream, 4) ... except ReadError: ... print(\"Read error\") Read error but the initial stream is partially consumed in the process: >>> stream.read(bytes) # doctest: +BYTES b'TA' This implementation therefore only provides some basic exception safety. A reader that preserves the original value of the stream when an error occurs would provide strong exception safety instead. With snapshots, the modifications required to support this are plain: we simply restore the original stream whenever an error occurs >>> def DNA_read(stream, n=1): ... DNA_bases = b\"ACGT\" ... snapshot = stream.save() ... try: ... bases = [] ... for i in range(n): ... base = stream.read(bytes, 1) ... if base not in DNA_bases: ... error = \"invalid base {0!r}\".format(base) ... raise ReadError(error) ... else: ... bases.append(base) ... return \"\".join(bases) ... except: ... stream.restore(snapshot) ... raise With this new version, reading an invalid DNA code still raises an exception >>> stream = BitStream(b\"GAUTA\") # invalid DNA sequence >>> try: ... DNA_read(stream, 4) ... except ReadError: ... print(\"Read error\") Read error but now the original stream is intact >>> stream.read(bytes) # doctest: +BYTES b'GAUTA'","title":"Exception Safety"},{"location":"snapshots/#multiple-snapshots","text":"You can create snapshots of a stream at any stage between read/write operations. Multiple snapshots enable for example the implemention a hierarchy of readers or writers that provide strong exception safety at every level. However arbitrary sequences of save and restore are not allowed: when a given snapshot is restored, the snapshots that were created between the snapshot creation and before its restoration are forgotten. In other words, saves and restores can only be applied in reverse order. Of course it is perfectly valid to skip some of the restores in the process: you can always create additional snapshots and never use them. For example, you can take two snapshots s0 then s1 of a stream between write operations >>> stream = BitStream() >>> s0 = stream.save() >>> stream.write(b\"A\") >>> s1 = stream.save() >>> stream.write(b\"B\") >>> stream == BitStream(b\"AB\") True restore s1 >>> stream.restore(s1) >>> stream == BitStream(b\"A\") True and then s0 >>> stream.restore(s0) >>> stream == BitStream(b\"\") True You can also make the same snapshots >>> stream = BitStream() >>> s0 = stream.save() >>> stream.write(b\"A\") >>> s1 = stream.save() >>> stream.write(b\"B\") >>> stream == BitStream(b\"AB\") True and directly restore s0 >>> stream.restore(s0) >>> stream == BitStream(b\"\") True but then s1 cannot be used anymore >>> stream.restore(s1) # doctest: +ELLIPSIS Traceback (most recent call last): ... ValueError: ...","title":"Multiple Snapshots"},{"location":"snapshots/#how-does-it-work","text":"The main (private) attributes of a BitStream structure are: an array of bytes: the raw data read and write cursors: they locate the beginning and the end of the stream in the bytes array. When you read data from a stream, you shift the read cursor but the corresponding data is not deleted 1 -- its is merely not accessible. The State structure stores values of the read and write cursors; the call state = stream.save() produces a snapshot of the current cursor locations and stream.restore(state) restores them. This is why the memory consumption increases if you write a lot of data into a stream, even if you read it! The solution in this case is to copy the stream and discard the original since the copy method discards write history. \u21a9","title":"How does it Work?"},{"location":"types/","text":"Built-in Types \u00b6 Bitstream reads and writes work out-of-the-box for many Python data types. It is also tightly integrated with NumPy , since this is the library of choice to deals with arrays of numeric data. >>> import bitstream >>> from bitstream import BitStream >>> from numpy import * Bools \u00b6 Write single bits to a bitstream with the arguments True and False : >>> stream = BitStream() >>> stream.write(False, bool) >>> stream.write(True , bool) >>> stream 01 Read them back in the same order with >>> stream.read(bool) False >>> stream.read(bool) True >>> stream <BLANKLINE> Write multiple bits at once with lists of bools: >>> stream = BitStream() >>> stream.write([], bool) >>> stream <BLANKLINE> >>> stream.write([False], bool) >>> stream.write([True] , bool) >>> stream 01 >>> stream.write([False, True], bool) >>> stream 0101 Alternatively, specify the data type bool as a a keyword argument: >>> stream = BitStream() >>> stream.write(False, type=bool) >>> stream.write(True , type=bool) >>> stream 01 For single bools or lists of bools, this type information is optional: >>> stream = BitStream() >>> stream.write(False) >>> stream.write(True) >>> stream.write([]) >>> stream.write([False]) >>> stream.write([True]) >>> stream.write([False, True]) >>> stream 010101 To read one boolean from a stream, do >>> stream.read(bool) False >>> stream 10101 and to read several booleans, use the second method argument >>> stream.read(bool, 2) [True, False] >>> stream 101 Since the booleans are returned in a list when the second argument differs from the default value (which is None ), stream.read(bool, 1) is not same as stream.read(bool) : >>> copy = stream.copy() >>> stream.read(bool, 1) [True] >>> copy.read(bool) True Numpy bool_ scalars or one-dimensional arrays can be used instead: >>> bool_ # doctest: +ELLIPSIS <... 'numpy.bool_'> >>> stream = BitStream() >>> stream.write(bool_(False) , bool) >>> stream.write(bool_(True) , bool) >>> stream 01 >>> stream = BitStream() >>> empty = array([], dtype=bool) >>> stream.write(empty, bool) >>> stream <BLANKLINE> >>> stream.write(array([False]), bool) >>> stream.write(array([True]) , bool) >>> stream.write(array([False, True]), bool) >>> stream 0101 For such data, the type information is also optional: >>> stream = BitStream() >>> stream.write(bool_(False)) >>> stream.write(bool_(True)) >>> stream.write(array([], dtype=bool)) >>> stream.write(array([False])) >>> stream.write(array([True])) >>> stream.write(array([False, True])) >>> stream 010101 Actually, many more types can be used as booleans when the type information is explicit. For example, Python and Numpy numeric types are valid arguments: zero is considered false and nonzero numbers are considered true. >>> stream = BitStream() >>> stream.write(0.0, bool) >>> stream.write(1.0, bool) >>> stream.write(pi , bool) >>> stream.write(float64(0.0), bool) >>> stream.write(float64(1.0), bool) >>> stream.write(float64(pi) , bool) >>> stream 011011 Strings are also valid arguments, with a boolean value of True unless they are empty. One-dimensional lists and numpy arrays are considered holders of multiple data, each of which is converted to bool. >>> bool(b\"\") False >>> bool(b\" \") True >>> bool(b\"A\") True >>> bool(b\"AAA\") True >>> stream = BitStream() >>> stream.write(b\"\", bool) >>> stream.write(b\" \", bool) >>> stream.write(b\"A\", bool) >>> stream.write(b\"AAA\", bool) >>> stream 0111 >>> stream = BitStream() >>> stream.write([b\"\", b\" \" , b\"A\", b\"AAA\"], bool) >>> stream 0111 >>> stream = BitStream() >>> stream.write(array([b\"\", b\" \" , b\"A\", b\"AAA\"]), bool) >>> stream 0111 Any other sequence (strings, tuples, lists nested in lists, etc.) is considered as a single datum. >>> stream = BitStream() >>> stream.write( (), bool) >>> stream.write( (0,), bool) >>> stream.write((0, 0), bool) >>> stream 011 >>> stream = BitStream() >>> stream.write([[], [0], [0, 0]], bool) >>> stream 011 More generally, arbitrary custom \"bool-like\" instances, which have a __bool__ method (or __nonzero__ for Python 2) to handle the conversion to boolean, can also be used: >>> class BoolLike(object): ... def __init__(self, value): ... self.value = bool(value) ... def __bool__(self): ... return self.value ... __nonzero__ = __bool__ >>> false = BoolLike(False) >>> true = BoolLike(True) >>> stream = BitStream() >>> stream.write(false, bool) >>> stream.write(true, bool) >>> stream.write([false, true], bool) >>> stream 0101 BitStreams \u00b6 A lists of bool is not the most efficient way to represent a binary stream. The best type is ... an instance of BitStream of course! Consider the stream >>> stream = BitStream() >>> stream.write(8 * [True], bool) >>> stream 11111111 To read 2 bits out of stream as a bitstream, use >>> stream.read(BitStream, 2) 11 Since this is a common use case, the BitStream type is assumed by default: >>> new_stream = stream.read(n=2) >>> type(new_stream) is BitStream True >>> new_stream 11 The simpler code below also works: >>> new_stream = stream.read(2) >>> type(new_stream) is BitStream True >>> new_stream 11 When the number of items to read is also specified ( n=None ), the read empties the stream: >>> stream.read() 11 >>> stream <BLANKLINE> Strings \u00b6 In Python 2.7, strings are the structure of choice to represent bytes in memory. Their type is str (or equivalently bytes which is an alias). Fortunately, it's straightforward to convert strings to bitstreams: create a stream from the string \"ABCD\" with >>> stream = BitStream(b\"ABCD\") To be totally explicit, the code above is equivalent to: >>> stream = BitStream() >>> stream.write(b\"ABCDE\", bytes) Now, the content of the stream is >>> stream 0100000101000010010000110100010001000101 It is the binary representation of the ASCII codes of the string characters, as unsigned 8-bit integers (see Integers for more details): >>> char_codes = [ord(char) for char in \"ABCDE\"] >>> char_codes [65, 66, 67, 68, 69] >>> stream == BitStream(char_codes, uint8) True There is no \"single character\" type in Python: characters are represented as bytes of length 1. To read one or several characters from a bitstream, use the read method with the bytes type: >>> stream.read(bytes, 1) # doctest: +BYTES b'A' >>> stream.read(bytes, 2) # doctest: +BYTES b'BC' Without an explicit number of characters, the bitstream is emptied >>> stream.read(bytes) # doctest: +BYTES b'DE' but that works only if the bitstream contains a multiple of 8 bits. >>> stream = BitStream(42 * [True]) >>> try: ... stream.read(bytes) ... except bitstream.ReadError: ... print(\"42 is not a multiple of 8\") 42 is not a multiple of 8 To accept up to seven trailing bits instead, use the more explicit code: >>> stream = BitStream(42 * [True]) >>> n = len(stream) // 8 >>> n 5 >>> stream.read(bytes, n) # doctest: +BYTES b'\\xff\\xff\\xff\\xff\\xff' >>> stream 11 Integers \u00b6 First, let's clear something out: since Python integers can be of arbitrary size and there is not a unique convenient and commonly accepted representation for such integers 1 , you cannot create a bitstream from Python integers by default. >>> BitStream(1) Traceback (most recent call last): ... TypeError: unsupported type 'int'. >>> BitStream(2**100) # doctest: +ELLIPSIS Traceback (most recent call last): ... TypeError: unsupported type ... >>> BitStream(b\"A\").read(int) Traceback (most recent call last): ... TypeError: unsupported type 'int'. You need to specify somehow an integer type that determines what binary representation should be used. For example, to represent 1 as an unsigned 8bit integer: >>> BitStream(1, uint8) 00000001 >>> BitStream(uint8(1)) 00000001 For integer sequences, there are even more ways to specify the integer type: >>> BitStream([1,2,3], uint8) 000000010000001000000011 >>> BitStream([uint8(1), uint8(2), uint8(3)]) 000000010000001000000011 >>> BitStream(array([1, 2, 3], dtype=uint8)) 000000010000001000000011 Bitstream supports six integer types from numpy: unsigned integers: uint8 , uint16 , uint32 signed integers: int8 , int16 , int32 The representation of unsigned integers is based on their decomposition as powers of 2. For example, since >>> 13 == 1*2**3 + 1*2**2 + 0*2**1 + 1*2**0 True we have >>> BitStream(13, uint8) 00001101 In this scheme, only unsigned integers in the range 0-255 can be represented as 8bit integers. Out-of-bounds integers are accepted, but mapped to the correct range by a modulo 2**8 operation. Numpy follows this convention >>> 500 % 2**8 244 >>> uint8(500) 244 and so does bitstream >>> BitStream(500, uint8) 11110100 >>> BitStream(244, uint8) 11110100 >>> BitStream(500, uint8).read(uint8) 244 The representation of 16bit and 32bit unsigned integers follows the same approach >>> BitStream(2**10, uint16) 0000010000000000 >>> BitStream(uint16(2**10)) 0000010000000000 For the readers that know about this, we use the big-endian representation by default for multi-byte integers. If you want to use the little-endian convention instead, NumPy provides the method newbyteorder for this: >>> BitStream(uint16(2**10).newbyteorder()) 0000000000000100 Finally, for signed integers, we use the two's complement representation >>> BitStream(0, int8) 00000000 >>> BitStream(1, int8) 00000001 >>> BitStream(-1, int8) 11111111 Floating-Point Numbers \u00b6 Bitstream supports natively the IEE754 double-precision floating-point numbers, which have a well-defined binary representation (see e.g. What every computer scientist should know about binary arithmetic ). >>> stream = BitStream() >>> stream.write(0.0) >>> stream.write([1.0, 2.0, 3.0]) >>> stream.write(arange(4.0, 10.0)) >>> len(stream) 640 >>> output = stream.read(float, 10) >>> type(output) # doctest: +ELLIPSIS <... 'numpy.ndarray'> >>> all(output == arange(10.0)) True Python built-in float type and NumPy float64 types may be used interchangeably: >>> BitStream(1.0) == BitStream(1.0, float) == BitStream(1.0, float64) True Scalar, lists and arrays of floats are supported: >>> BitStream(1.0) == BitStream([1.0]) == BitStream(ones(1)) True The byte order is big endian: >>> import struct >>> PI_BE = struct.pack(b\">d\", pi) >>> PI_BE # doctest: +BYTES b'@\\t!\\xfbTD-\\x18' >>> BitStream(pi) == BitStream(PI_BE) True The NumPy newbyteorder method should be used beforeand (on a float64 or an array of floats) to get a little-endian representation instead. Why not simply use the binary decomposition of integers? For example, since >>> 13 == 1*2**3 + 1*2**2 + 0*2**1 + 1*2**0 True you may be tempted to not represent 13 as >>> BitStream([True, True, False, True]) 1101 But this scheme is ambiguous if we consider sequences of integers: 1101 could represent the integer 13 but also [1,5] or [3,1] or [3,0,1] , etc. \u21a9","title":"Built-in Types"},{"location":"types/#built-in-types","text":"Bitstream reads and writes work out-of-the-box for many Python data types. It is also tightly integrated with NumPy , since this is the library of choice to deals with arrays of numeric data. >>> import bitstream >>> from bitstream import BitStream >>> from numpy import *","title":"Built-in Types"},{"location":"types/#bools","text":"Write single bits to a bitstream with the arguments True and False : >>> stream = BitStream() >>> stream.write(False, bool) >>> stream.write(True , bool) >>> stream 01 Read them back in the same order with >>> stream.read(bool) False >>> stream.read(bool) True >>> stream <BLANKLINE> Write multiple bits at once with lists of bools: >>> stream = BitStream() >>> stream.write([], bool) >>> stream <BLANKLINE> >>> stream.write([False], bool) >>> stream.write([True] , bool) >>> stream 01 >>> stream.write([False, True], bool) >>> stream 0101 Alternatively, specify the data type bool as a a keyword argument: >>> stream = BitStream() >>> stream.write(False, type=bool) >>> stream.write(True , type=bool) >>> stream 01 For single bools or lists of bools, this type information is optional: >>> stream = BitStream() >>> stream.write(False) >>> stream.write(True) >>> stream.write([]) >>> stream.write([False]) >>> stream.write([True]) >>> stream.write([False, True]) >>> stream 010101 To read one boolean from a stream, do >>> stream.read(bool) False >>> stream 10101 and to read several booleans, use the second method argument >>> stream.read(bool, 2) [True, False] >>> stream 101 Since the booleans are returned in a list when the second argument differs from the default value (which is None ), stream.read(bool, 1) is not same as stream.read(bool) : >>> copy = stream.copy() >>> stream.read(bool, 1) [True] >>> copy.read(bool) True Numpy bool_ scalars or one-dimensional arrays can be used instead: >>> bool_ # doctest: +ELLIPSIS <... 'numpy.bool_'> >>> stream = BitStream() >>> stream.write(bool_(False) , bool) >>> stream.write(bool_(True) , bool) >>> stream 01 >>> stream = BitStream() >>> empty = array([], dtype=bool) >>> stream.write(empty, bool) >>> stream <BLANKLINE> >>> stream.write(array([False]), bool) >>> stream.write(array([True]) , bool) >>> stream.write(array([False, True]), bool) >>> stream 0101 For such data, the type information is also optional: >>> stream = BitStream() >>> stream.write(bool_(False)) >>> stream.write(bool_(True)) >>> stream.write(array([], dtype=bool)) >>> stream.write(array([False])) >>> stream.write(array([True])) >>> stream.write(array([False, True])) >>> stream 010101 Actually, many more types can be used as booleans when the type information is explicit. For example, Python and Numpy numeric types are valid arguments: zero is considered false and nonzero numbers are considered true. >>> stream = BitStream() >>> stream.write(0.0, bool) >>> stream.write(1.0, bool) >>> stream.write(pi , bool) >>> stream.write(float64(0.0), bool) >>> stream.write(float64(1.0), bool) >>> stream.write(float64(pi) , bool) >>> stream 011011 Strings are also valid arguments, with a boolean value of True unless they are empty. One-dimensional lists and numpy arrays are considered holders of multiple data, each of which is converted to bool. >>> bool(b\"\") False >>> bool(b\" \") True >>> bool(b\"A\") True >>> bool(b\"AAA\") True >>> stream = BitStream() >>> stream.write(b\"\", bool) >>> stream.write(b\" \", bool) >>> stream.write(b\"A\", bool) >>> stream.write(b\"AAA\", bool) >>> stream 0111 >>> stream = BitStream() >>> stream.write([b\"\", b\" \" , b\"A\", b\"AAA\"], bool) >>> stream 0111 >>> stream = BitStream() >>> stream.write(array([b\"\", b\" \" , b\"A\", b\"AAA\"]), bool) >>> stream 0111 Any other sequence (strings, tuples, lists nested in lists, etc.) is considered as a single datum. >>> stream = BitStream() >>> stream.write( (), bool) >>> stream.write( (0,), bool) >>> stream.write((0, 0), bool) >>> stream 011 >>> stream = BitStream() >>> stream.write([[], [0], [0, 0]], bool) >>> stream 011 More generally, arbitrary custom \"bool-like\" instances, which have a __bool__ method (or __nonzero__ for Python 2) to handle the conversion to boolean, can also be used: >>> class BoolLike(object): ... def __init__(self, value): ... self.value = bool(value) ... def __bool__(self): ... return self.value ... __nonzero__ = __bool__ >>> false = BoolLike(False) >>> true = BoolLike(True) >>> stream = BitStream() >>> stream.write(false, bool) >>> stream.write(true, bool) >>> stream.write([false, true], bool) >>> stream 0101","title":"Bools"},{"location":"types/#bitstreams","text":"A lists of bool is not the most efficient way to represent a binary stream. The best type is ... an instance of BitStream of course! Consider the stream >>> stream = BitStream() >>> stream.write(8 * [True], bool) >>> stream 11111111 To read 2 bits out of stream as a bitstream, use >>> stream.read(BitStream, 2) 11 Since this is a common use case, the BitStream type is assumed by default: >>> new_stream = stream.read(n=2) >>> type(new_stream) is BitStream True >>> new_stream 11 The simpler code below also works: >>> new_stream = stream.read(2) >>> type(new_stream) is BitStream True >>> new_stream 11 When the number of items to read is also specified ( n=None ), the read empties the stream: >>> stream.read() 11 >>> stream <BLANKLINE>","title":"BitStreams"},{"location":"types/#strings","text":"In Python 2.7, strings are the structure of choice to represent bytes in memory. Their type is str (or equivalently bytes which is an alias). Fortunately, it's straightforward to convert strings to bitstreams: create a stream from the string \"ABCD\" with >>> stream = BitStream(b\"ABCD\") To be totally explicit, the code above is equivalent to: >>> stream = BitStream() >>> stream.write(b\"ABCDE\", bytes) Now, the content of the stream is >>> stream 0100000101000010010000110100010001000101 It is the binary representation of the ASCII codes of the string characters, as unsigned 8-bit integers (see Integers for more details): >>> char_codes = [ord(char) for char in \"ABCDE\"] >>> char_codes [65, 66, 67, 68, 69] >>> stream == BitStream(char_codes, uint8) True There is no \"single character\" type in Python: characters are represented as bytes of length 1. To read one or several characters from a bitstream, use the read method with the bytes type: >>> stream.read(bytes, 1) # doctest: +BYTES b'A' >>> stream.read(bytes, 2) # doctest: +BYTES b'BC' Without an explicit number of characters, the bitstream is emptied >>> stream.read(bytes) # doctest: +BYTES b'DE' but that works only if the bitstream contains a multiple of 8 bits. >>> stream = BitStream(42 * [True]) >>> try: ... stream.read(bytes) ... except bitstream.ReadError: ... print(\"42 is not a multiple of 8\") 42 is not a multiple of 8 To accept up to seven trailing bits instead, use the more explicit code: >>> stream = BitStream(42 * [True]) >>> n = len(stream) // 8 >>> n 5 >>> stream.read(bytes, n) # doctest: +BYTES b'\\xff\\xff\\xff\\xff\\xff' >>> stream 11","title":"Strings"},{"location":"types/#integers","text":"First, let's clear something out: since Python integers can be of arbitrary size and there is not a unique convenient and commonly accepted representation for such integers 1 , you cannot create a bitstream from Python integers by default. >>> BitStream(1) Traceback (most recent call last): ... TypeError: unsupported type 'int'. >>> BitStream(2**100) # doctest: +ELLIPSIS Traceback (most recent call last): ... TypeError: unsupported type ... >>> BitStream(b\"A\").read(int) Traceback (most recent call last): ... TypeError: unsupported type 'int'. You need to specify somehow an integer type that determines what binary representation should be used. For example, to represent 1 as an unsigned 8bit integer: >>> BitStream(1, uint8) 00000001 >>> BitStream(uint8(1)) 00000001 For integer sequences, there are even more ways to specify the integer type: >>> BitStream([1,2,3], uint8) 000000010000001000000011 >>> BitStream([uint8(1), uint8(2), uint8(3)]) 000000010000001000000011 >>> BitStream(array([1, 2, 3], dtype=uint8)) 000000010000001000000011 Bitstream supports six integer types from numpy: unsigned integers: uint8 , uint16 , uint32 signed integers: int8 , int16 , int32 The representation of unsigned integers is based on their decomposition as powers of 2. For example, since >>> 13 == 1*2**3 + 1*2**2 + 0*2**1 + 1*2**0 True we have >>> BitStream(13, uint8) 00001101 In this scheme, only unsigned integers in the range 0-255 can be represented as 8bit integers. Out-of-bounds integers are accepted, but mapped to the correct range by a modulo 2**8 operation. Numpy follows this convention >>> 500 % 2**8 244 >>> uint8(500) 244 and so does bitstream >>> BitStream(500, uint8) 11110100 >>> BitStream(244, uint8) 11110100 >>> BitStream(500, uint8).read(uint8) 244 The representation of 16bit and 32bit unsigned integers follows the same approach >>> BitStream(2**10, uint16) 0000010000000000 >>> BitStream(uint16(2**10)) 0000010000000000 For the readers that know about this, we use the big-endian representation by default for multi-byte integers. If you want to use the little-endian convention instead, NumPy provides the method newbyteorder for this: >>> BitStream(uint16(2**10).newbyteorder()) 0000000000000100 Finally, for signed integers, we use the two's complement representation >>> BitStream(0, int8) 00000000 >>> BitStream(1, int8) 00000001 >>> BitStream(-1, int8) 11111111","title":"Integers"},{"location":"types/#floating-point-numbers","text":"Bitstream supports natively the IEE754 double-precision floating-point numbers, which have a well-defined binary representation (see e.g. What every computer scientist should know about binary arithmetic ). >>> stream = BitStream() >>> stream.write(0.0) >>> stream.write([1.0, 2.0, 3.0]) >>> stream.write(arange(4.0, 10.0)) >>> len(stream) 640 >>> output = stream.read(float, 10) >>> type(output) # doctest: +ELLIPSIS <... 'numpy.ndarray'> >>> all(output == arange(10.0)) True Python built-in float type and NumPy float64 types may be used interchangeably: >>> BitStream(1.0) == BitStream(1.0, float) == BitStream(1.0, float64) True Scalar, lists and arrays of floats are supported: >>> BitStream(1.0) == BitStream([1.0]) == BitStream(ones(1)) True The byte order is big endian: >>> import struct >>> PI_BE = struct.pack(b\">d\", pi) >>> PI_BE # doctest: +BYTES b'@\\t!\\xfbTD-\\x18' >>> BitStream(pi) == BitStream(PI_BE) True The NumPy newbyteorder method should be used beforeand (on a float64 or an array of floats) to get a little-endian representation instead. Why not simply use the binary decomposition of integers? For example, since >>> 13 == 1*2**3 + 1*2**2 + 0*2**1 + 1*2**0 True you may be tempted to not represent 13 as >>> BitStream([True, True, False, True]) 1101 But this scheme is ambiguous if we consider sequences of integers: 1101 could represent the integer 13 but also [1,5] or [3,1] or [3,0,1] , etc. \u21a9","title":"Floating-Point Numbers"}]}